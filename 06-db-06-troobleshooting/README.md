## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB  
## Ответ:  
Определим текущую операцию командой:    
       db.currentOp()  
Завершим операцию по opid  
       db.killOp()  
Чтобы не попадать в такую ситуацию, возможно использование параметра maxTimeMS() для запросов CRUD

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:  
- сначала рост отношения записанных значений к истекшим  
- Redis блокирует операции записи  

Как вы думаете, в чем может быть проблема?  
## Ответ:  
В Redis есть два способа очистить просроченные записи: "ленивый" и "активный". В случае с ленивым - просроченные записи запрашиваются командой, активный способ - повторяется каждые 100 миллисекунд и проводит записи в состояние устаревшие, затем данные записи исключаются. ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP по умолчанию имеет значение 20, таким образом за раз можно пометить и очистить около 200 устаревших записей. Процесс проверки зациклится и мы ощутим задержки, а потом и вовсе не будут приниматься данные на запись, если появятся истекшие записи более 25% по отношению ко всем. В данном случае как раз так и получается. Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек.
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?  
## Ответ:  
Можете получать эти ошибки, если отправляются на сервер неверные или слишком большие запросы. Если mysqld получает пакет, который слишком велик или не соответствует порядку, он предполагает, что что-то пошло не так с клиентом, и закрывает соединение. Если вам нужны большие запросы (например, если вы работаете с большими столбцами BLOB), вы можете увеличить лимит запросов, задав серверную переменную max_allowed_packet, которая по умолчанию имеет значение 1 МБ. Вам также может потребоваться увеличить максимальный размер пакета на стороне клиента.
## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer` 

Как вы думаете, что происходит?

Как бы вы решили данную проблему?  
## Ответ:  
Когда памяти не хватает, вызывается oom-killer и уничтожается процесс PostgreSQL чтобы предотвратить падение всей системы. Для предотвращения сбоев , необходимо увеличить объем ОЗУ или выставить ограничение в настройках PG на использование ресурсов хоста, 
чтобы исключить потребление всех ресурсов на машине.
